# @title Print results of different types of analyses
# @description Takes an object, and prints the results as an APA table.
# @param x Object to be printed
# @param columns Character vector, indicating the columns to retain.
# Default: c("label", "est_sig", "confint").
# @param digits Integet. Number of digits to round to when formatting;
# Default: 2.
# @param ... Other arguments passed to and from other functions.
# @return data.frame
# @rdname table_results
# @export
# table_results <- function(x, columns = c("label",
#                                          "est_sig", "confint"), digits = 2, ...){
#   UseMethod("table_results", x)
# }

#' @method table_results rma
#' @export
table_results.rma <-  function(x, columns = c("label", "est_sig", "se", "pval", "confint", "group", "level"), digits = 2, ...){

  results <- do.call(cbind, x[c("b", "se", "zval", "pval", "ci.lb", "ci.ub")])
  results <- data.frame(label = rownames(results), results)
  names(results)[2] <- c("est")
  value_columns <- c("est", "se", "zval", "pval", "ci.lb", "ci.ub")
  value_columns <- value_columns[which(value_columns %in%
                                         colnames(results))]
  add_cis <- TRUE
  results$est_sig <- est_sig(results, digits)

  results$confint <- conf_int(results, digits)

  results[, value_columns] <- lapply(results[, value_columns],
                                     formatC, digits = digits, format = "f")
  rownames(results) <- NULL
  if(!all){
    results <- results[, c("b", "se", "zval", "pval", "ci.lb", "ci.ub")]
  } else {
    results
  }
}

# Change which columns table_results reports
#
# Sets a global option to control which columns table_results reports when
# \code{all = FALSE}.
# @param x A character vector with column names for
# \code{\link[tidySEM]{table_results}}.
# @author Caspar J. van Lissa
# @family Reporting tools
# @keywords reporting
# @export
# @examples
# report_columns(c("label", "est_sig", "se", "pval", "confint", "group"))
report_columns <- function(x = c("label", "est_sig", "se", "pval", "confint", "group", "level")){
  x <- list("report_columns" = x)
  do.call(options, x)
}

#' Print results table formatted for publication
#'
#' Takes a model object, and formats it as a publication-ready table.
#' @param x A model object for which a method exists.
# @param standardized Logical. Return standardized parameters, or not.
# Defaults to TRUE.
# @param all Logical. Whether to return all available results columns
# (including columns generated by \code{table_results}, or whether to return a
# simplified table containing the essential columns for APA-style reporting.
# Defaults to FALSE. If set to TRUE, you can manually select the desired
# columns.
#' @param columns A character vector of columns to retain from the results
#' section. If this is set to \code{NULL}, all available columns are returned.
#' Defaults to \code{c("label", "est_sig", "se", "pval", "confint", "group",
#' "level")}. These correspond to 1) the parameter label, 2) estimate column
#' with significance asterisks appended
#' (\* <.05, \*\* < .01, \*\*\* < .001); 3) standard error, 4) p-value, 5) a
#' formatted confidence interval, 6) grouping variable (if available), 7) level
#' variable for multilevel models, if available.
#' @param digits Number of digits to round to when formatting numeric columns.
#' @param ... Logical expressions used to filter the rows of results returned.
#' @return A data.frame of formatted Mplus results.
#' @author Caspar J. van Lissa
#' @family Reporting tools
#' @keywords reporting
#' @export
#' @examples
#' #Make me!
table_results <- function(x, columns = c("label", "est_sig", "se", "pval", "confint", "group", "level"), digits = 2, ...){
  UseMethod("table_results")
}

#' @method table_results mplusObject
#' @export
table_results.mplusObject <- function(x, columns = c("label", "est_sig", "se", "pval", "confint", "group", "level"), digits = 2, ...){
  Args <- as.list(match.call()[-1])
  Args$x <- x$results
  do.call(table_results, Args)
}


#' @method table_results mplus.model
#' @export
table_results.mplus.model <- function(x, columns = c("label", "est_sig", "se", "pval", "confint", "group", "level"), digits = 2, ...){
  Args <- list(x = x)
  digits <- force(digits)
  get_res <- c("unstandardized", "stdyx.standardized")[which( c("unstandardized", "stdyx.standardized") %in% names(x$parameters))]
  all_res <- lapply(get_res, function(which_par){do.call(internal_table_mplusmodel, c(Args, list(parameters = which_par, digits = digits)))})
  if(length(all_res) == 1){
    results <- all_res[[1]]
  } else {
    all_res[[2]][c("paramHeader", "param", "est_se", "Group", "betweenwithin", "label")] <- NULL
    names(all_res[[2]])[-ncol(all_res[[2]])] <- paste0(names(all_res[[2]])[-ncol(all_res[[2]])], "_std")
    results <- merge(all_res[[1]], all_res[[2]], by = "id", all.x = TRUE)
    results["id"] <- NULL
  }
  results <- data.frame(mplus_to_lavaan_labels(results$paramHeader, results$param), results, stringsAsFactors = FALSE)
  if(any(results$paramHeader == "New.Additional.Parameters")){
    results$rhs[results$op == ":="] <- sapply(results$lhs[results$op == ":="], function(constr){
      trimws(gsub("^.+?=(.+);", "\\1", x$input$model.constraint[grepl(paste0("(?<=\\s)", tolower(constr), "(?=[= ])"), tolower(x$input$model.constraint), perl = TRUE)]))
    })
  }
  names(results) <- tolower(names(results))
  if("betweenwithin" %in% names(results)) names(results)[names(results) == "betweenwithin"] <- "level"

  if(!is.null(columns)){
    #if(standardized){
    #  columns[na.omit(match(c("est", "est_sig", "se", "pval", "confint"), columns))] <- paste0(columns[na.omit(match(c("est", "est_sig", "se", "pval", "confint"), columns))], "_std")
    #}
    results <- results[, na.omit(match(columns, names(results)))]
  } else {
    order_cols <- c("group", "level", "label")
    order_cols <- order_cols[order_cols %in% names(results)]
    remaining_cols <- names(results)[(length(order_cols)+6):(ncol(results))]
    remaining_cols <- remaining_cols[!remaining_cols %in% order_cols]
    order_cols <- c(1:5, match(order_cols, names(results)), match(remaining_cols, names(results)))
    results <- results[, order_cols]
  }
  class(results) <- c("tidy_results", class(results))
  results
}

internal_table_mplusmodel <- function(x, parameters, digits){
  results <- x$parameters[[parameters]]
  value_columns <- c("est", "se", "est_se", "pval", "posterior_sd")
  value_columns <- value_columns[which(value_columns %in% names(results))]
  add_cis <- FALSE
  if(!is.null(x$parameters[[paste0("ci.", parameters)]])){
    if(dim(results)[1]==dim(x$parameters[[paste0("ci.", parameters)]])[1]){
      add_cis <- TRUE
      results <- cbind(results, x$parameters[[paste0("ci.", parameters)]][, c("low2.5", "up2.5")])
    }
  }

  if(!is.null(x$indirect[[parameters]])){
    overall <- x$indirect[[parameters]]$overall
    if(!is.null(overall)){
      if(!is.null(overall[["summary"]])){
        paramHeader <- gsub("\\s+", "\\.", overall[["summary"]])
      } else {
        paramHeader <- "Sum.of.indirect"
      }
      param <- paste(overall$outcome, overall$pred, sep = ".")
      overall$pred <- paramHeader
      overall$outcome <- param
      names(overall)[c(1, 2)] <- c("paramHeader", "param")
      if(add_cis){
        overall <- cbind(overall, x$indirect[[paste0("ci.", parameters)]]$overall[, c("low2.5", "up2.5")])
      }
      names(overall)[match(tolower(names(results)), tolower(names(overall)))] <- names(results)[na.omit(match(tolower(names(overall)), tolower(names(results))))]
      results <- rbind(results, overall[, match(names(results), names(overall))])
    }

    specific <- x$indirect[[parameters]]$specific
    if(!is.null(specific)){
      paramHeader <- "Specific.indirect"
      param <- paste(specific$pred, specific$intervening, specific$outcome, sep = ".")
      specific$pred <- paramHeader
      specific$intervening <- param
      names(specific)[c(1, 2)] <- c("paramHeader", "param")
      if(add_cis){
        specific <- cbind(specific, x$indirect[[paste0("ci.", parameters)]]$specific[, c("low2.5", "up2.5")])
      }
      names(specific)[match(tolower(names(results)), tolower(names(specific)))] <- names(results)[na.omit(match(tolower(names(specific)), tolower(names(results))))]
      results <- rbind(results, specific[, match(names(results), names(specific))])
    }
  }

  var_classes <- sapply(results[value_columns], class)
  results[value_columns[which(var_classes == "character")]] <- lapply(results[value_columns[which(var_classes == "character")]], as.numeric)
  results[value_columns[which(var_classes == "factor")]] <- lapply(results[value_columns[which(var_classes == "factor")]], as.numeric.factor)

  constrained_rows <- results$pval == 999

  results$label <- param_label(results)
  if(all(c("est", "pval") %in% names(results))){
    results$est_sig <- est_sig(results)
  }
  results$confint <- conf_int(results, digits)

  results[, value_columns] <- lapply(results[, value_columns], formatC, digits = digits, format = "f")
  results[constrained_rows, which(names(results) %in% c("se", "pval", "est_se", "confint"))] <- ""
  id_cols <- c("paramHeader", "param", "Group", "betweenwithin", "LatentClass")
  results$id <- do.call(paste0, results[which(names(results) %in% id_cols)])
  results
}

mplus_to_lavaan_labels <- function(paramHeader, param){
  op <- paramHeader
  op[grepl("^.+?\\.\\|$", op)] <- "=~"
  op[op == "New.Additional.Parameters"] <- ":="
  op[op == "Thresholds"] <- "|"
  op[op %in% c("Residual.Variances", "Variances")] <- "~~"
  with_statements <- grepl("^.+?\\.WITH$", op)
  op[with_statements] <- "~~"
  op[op %in% c("Means", "Intercepts")] <- "~1"
  op[grepl("^.+?\\.ON$", op)] <- "~"
  op[grepl("^.+?\\.BY$", op)] <- "=~"

  rhs <- lhs <- param
  rhs[op == "~1"] <- ""
  lhs[op %in% c("~", "=~")] <- unlist(sapply(strsplit(paramHeader[op %in% c("~", "=~")], "\\."), `[`, 1))
  lhs[with_statements] <- unlist(sapply(strsplit(paramHeader[with_statements], "\\."), `[`, 1))
  cbind(lhs, op, rhs)
}

lavaan_labels <- function(x){
  x$left <- x$mid <- ""
  x$mid[x$op == "=~"] <- "BY"
  x$mid[x$op == ":="] <- ":="
  x$left[x$op == "|"] <- "Thresholds"
  #x$rhs[x$op == "|"] <- paste0(".", x$rhs[x$op == "|"])
  x$mid[x$op == "~~" & !(x$lhs == x$rhs)] <- "WITH"
  x$left[x$op == "~1"] <- "Means"
  x$mid[x$op == "~"] <- "ON"
  x$left[x$op %in% c("~~", "~*~") & x$lhs == x$rhs] <- "Variances"
  x$rhs[x$op %in% c("~~", "~*~") & x$lhs == x$rhs] <- ""

  apply(x[c("left", "lhs", "mid", "rhs")], 1, function(i){
    paste0(i[!i==""], collapse = ".")
  })
}

#' Add significance asterisks to object
#'
#' Takes a model object, and adds significance asterisks to the estimate column.
#' @param x A model object for which a method exists.
#' @param digits Integer. The number of digits to round the estimate column to.
#' @param sig Optional, a vector of p-values for the default method.
#' @return A character vector of formatted estimates.
#' @author Caspar J. van Lissa
#' @family Reporting tools
#' @seealso table_results
#' @export
#' @examples
#' est_sig(c(.222, .3333), sig = c(.054, .045))
est_sig <- function(x, digits = 2, sig = NULL){
  UseMethod("est_sig")
}

#' @method est_sig default
#' @export
est_sig.default <- function(x, digits = 2, sig = NULL){
  out <- formatC(x, digits = digits, format = "f")
  out[which(sig<.05)] <- paste0(out[which(sig<.05)], "*")
  out[which(sig<.01)] <- paste0(out[which(sig<.01)], "*")
  out[which(sig<.001)] <- paste0(out[which(sig<.001)], "*")
  out
}

#' @method est_sig mplus.params
#' @export
est_sig.mplus.params <- function(x, digits = 2, sig = NULL){
  Args <- list(x = x[["est"]],
               sig = x[["pval"]])
  do.call(est_sig, Args)
}

#  paste0(formatC(mplusresults$est, digits = digits, format = "f"), ifelse(mplusresults$pval<.05, "*", ""), ifelse(mplusresults$pval<.01, "*", ""), ifelse(mplusresults$pval<.001, "*", ""))
#}


#' Format confidence intervals
#'
#' Creates APA-formated confidence intervals, either from an object for which a
#' method exists, or from the arguments \code{lb} and \code{ub}. When argument
#' \code{x} is a numeric vector, it is also possible to construct a confidence
#' interval using the standard error (\code{se}) and a percentile interval
#' (\code{ci}).
#' @param x Optional. An object for which a method exists.
#' @param digits Integer. The number of digits to round the condidence
#' boundaries to.
#' @param se Optional, numeric. Standard error of the parameters.
#' @param lb Optional, numeric. Lower boundary of confidence intervals.
#' @param ub Optional, numeric. Upper boundary of confidence intervals.
#' @param ci Optional, numeric. What percentage CI to use (only used when
#' computing CI from a numeric vector \code{x}, and the standard error
#' \code{se}, based on a normal distribution).
#' @return A character vector of formatted confidence intervals.
#' @author Caspar J. van Lissa
#' @family Reporting tools
#' @seealso table_results est_sig
#' @export
#' @examples
#' conf_int(x = c(1.325, 2.432), se = c(.05336, .00325))
conf_int <- function(x, digits = 2, se = NULL, lb = NULL, ub = NULL, ci = 95){
  UseMethod("conf_int")
}

#' @method conf_int default
#' @export
#' @importFrom stats qnorm
conf_int.default <- function(x, digits = 2, se = NULL, lb = NULL, ub = NULL, ci = 95){
  if(!is.null(se) & !is.null(lb) & !is.null(ub)) {
    message("Both se and lb/ub provided. Used lb/ub to construct confidence interval.", call. = FALSE)
    se <- NULL
  }
  if(!is.null(lb) & !is.null(ub)){
    paste0("[", formatC(lb, digits = digits, format = "f"), ", ", formatC(ub, digits = digits, format = "f"), "]")
  } else {
    if(!(ci>0 & ci < 100)) stop("Argument 'ci' must have a value between 0-100.", call. = FALSE)
    bound <- qnorm((1-(ci/100))/2)
    paste0("[", formatC(x+(bound*se), digits = digits, format = "f"), ", ", formatC(x-(bound*se), digits = digits, format = "f"), "]")
  }
}

#' @method conf_int mplus.params
#' @export
conf_int.mplus.params <- function(x, digits = 2, se = NULL, lb = NULL, ub = NULL, ci = 95){
  if("low2.5" %in% names(x) | "lower_2.5ci" %in% names(x)){
    if("low2.5" %in% names(x)){
      message("Used bootstrapped confidence intervals.")
      confint <- paste0("[", formatC(x$low2.5, digits = digits, format = "f"), ", ", formatC(x$up2.5, digits = digits, format = "f"), "]")
    } else {
      confint <- paste0("[", formatC(x$lower_2.5ci, digits = digits, format = "f"), ", ", formatC(x$upper_2.5ci, digits = digits, format = "f"), "]")
    }
  } else {
    message("Calculated confidence intervals from est and se.")
    confint <- paste0("[", formatC(x$est-(1.96*x$se), digits = digits, format = "f"), ", ", formatC(x$est+(1.96*x$se), digits = digits, format = "f"), "]")
  }
  gsub("^ \\[", "\\[ ", gsub("([^-]\\d\\.\\d{2})", " \\1", confint))
}

#' Add parameter labels to Mplus output
#'
#' Sometimes a single parameter label is more convenient than the two (or more)
#' columns returned by \code{readModels}. This function constructs parameter
#' labels by concatenating the paramHeader and param columns, or other relevant
#' label columns
#' @param mplusresults An mplusModel object, as returned by \code{readModels}.
#' @return A character vector of parameter labels.
#' @author Caspar J. van Lissa
#' @family Mplus functions
#' @seealso \code{\link[MplusAutomation]{readModels}}.
#' @export
#' @examples
#' data <- data.frame(paramHeader = c("F.BY", "F.BY"), param = c("A", "B"))
#' param_label(data)
param_label <- function(mplusresults){
  label_columns <- c("paramheader", "param", "pred", "intervening", "summary", "outcome", "group", "betweenwithin")
  label_columns <- names(mplusresults)[which(tolower(names(mplusresults)) %in% label_columns)]
  return(apply(mplusresults[label_columns], 1, paste0, collapse = "."))
  if(!is.null(mplusresults[["paramHeader"]])&!is.null(mplusresults[["param"]])){
    return(paste(mplusresults$paramHeader, mplusresults$param, sep = "."))
  }
  if(!is.null(mplusresults[["pred"]])&!is.null(mplusresults[["intervening"]])&!is.null(mplusresults[["outcome"]])){
    return(paste("IND", mplusresults$pred, mplusresults$intervening, mplusresults$outcome, sep = "."))
  }
  if(!is.null(mplusresults[["pred"]])&!is.null(mplusresults[["summary"]])&!is.null(mplusresults[["outcome"]])){
    return(paste(gsub("\\s", "\\.", mplusresults$summary), mplusresults$outcome, mplusresults$pred, sep = "."))
  }
}


#' Row-binds tables for publication
#'
#' Converts tables (data.frames, matrices) to character, and row-binds them,
#' inserting a label into the first column for each sub-table.
#' @param table_list A list of tables.
#' @return A table.
#' @author Caspar J. van Lissa
#' @family Mplus functions
#' @export
#' @examples
#' table_list <- list(
#'   table_f = data.frame(paramHeader = c("F.BY", "F.BY"), param = c("A", "B")),
#'   table_g = data.frame(paramHeader = c("G.BY", "G.BY"), param = c("A", "B")))
#' table_list <- list(
#'   data.frame(paramHeader = c("F.BY", "F.BY"), param = c("A", "B")),
#'   data.frame(paramHeader = c("G.BY", "G.BY"), param = c("A", "B")))
#' rbind_tables(table_list)
rbind_tables <- function(table_list){
  if(length(unique(sapply(table_list, ncol))) > 1) stop("Not all tables have the same number of columns.")
  if(is.null(names(table_list))) names(table_list) <- 1:length(table_list)
  do.call(rbind,
          lapply(names(table_list), function(x){
            rbind(
              c(x, rep("", (ncol(table_list[[x]])-1))), sapply(table_list[[x]], as.character))
          })
  )
}

#' Extract correlation tables from mplusModel
#'
#' Takes an mplusModel object returned by \code{readModels}, and extracts a
#' publication-ready correlation matrix.
#' @param mplusModel An mplusModel object, as returned by \code{readModels}.
#' @param parameters A character string corresponding to the name of an element
#' of the $parameters list in \code{mplusModel}. Usually one of
#' \code{c("unstandardized", "stdyx.standardized", "stdy.standardized")}.
#' @param valueColumn Character. Which column to use to propagate the matrix.
#' Defaults to "est_sig", the estimate with significance asterisks.
#' @param digits Number of digits to round to when formatting values.
#' @return A Matrix or a list of matrices (in case there are between/within
#' correlation matrices).
#' @author Caspar J. van Lissa
#' @family Mplus functions
#' @seealso \code{\link[MplusAutomation]{readModels}}.
#' @export
#' @examples
#' #Make me!
#' @importFrom stats na.omit reshape

table_cor <- function(mplusModel, parameters = "stdyx.standardized", valueColumn = "est_sig", digits = 2){
  correlations <- mplusModel$parameters[[parameters]]
  if("BetweenWithin" %in% names(correlations)){
    cornames <- unique(correlations$BetweenWithin)
    correlations <- lapply(cornames, function(x){
      correlations[correlations$BetweenWithin == x, ]
    })
    names(correlations) <- cornames
  } else {
    correlations <- list(correlations)
  }
  correlations <- lapply(correlations, function(cors){
    cors <- cors[grep("WITH$", cors$paramHeader), ]
    cors$paramHeader <- gsub("\\.WITH", "", cors$paramHeader)
    cors$paramHeader <- substr(cors$paramHeader,  1, 8)
    cors$param <- substr(cors$param,  1, 8)
    if(valueColumn == "est_sig"){
      cors$est_sig <- est_sig(cors, digits = digits)
    }
    if(valueColumn == "confint"){
      cors$confint <- conf_int(cors, digits = digits)
    }

    cors <- cors[ , c("paramHeader", "param", valueColumn)]
    cor_order <- unique(c(rbind(cors$paramHeader, cors$param)))
    names(cors)[3] <- "value"
    cors <- rbind(cors, data.frame(paramHeader = cors$param, param = cors$paramHeader, value = cors$value))
    cors <- rbind(cors, data.frame(paramHeader = unique(cors$paramHeader), param = unique(cors$paramHeader), value = rep(ifelse(valueColumn %in% c("est", "est_sig"), 1, NA), length(unique(cors$paramHeader)))))
    cors <- reshape(cors, v.names = "value", timevar = "paramHeader", idvar = "param", direction = "wide")
    names(cors) <- substr(names(cors), 7, 15)

    cors <- cors[match(cor_order, cors[[1]]), na.omit(match(cor_order, names(cors)))]
    row.names(cors) <- cor_order
    cors[is.na(cors)] <- ""
    cors
  })
  if(length(correlations) == 1){
    correlations <- correlations[[1]]
  }
  correlations
}


#' @importFrom utils getFromNamespace
#' @importFrom lavaan parametertable lavInspect standardizedsolution
lav_getParameterLabels <-
  getFromNamespace("getParameterLabels", "lavaan")

#' @importFrom lavaan parameterEstimates lavInspect standardizedsolution
#' @method table_results lavaan
#' @export
table_results.lavaan <- function(x, columns = c("label", "est_sig", "se", "pval", "confint", "group", "level"), digits = 2, ...){
# <- function(x, standardize, retain_which = c("~", "~~", "=~")){
  pars_unst <- parameterEstimates(x)
  pars_unst$label <- lavaan_labels(pars_unst)

  num_groups <- lavInspect(x, what = "ngroups")
  if(num_groups > 1){
    group_labels <- lavInspect(x, what = "group.label")
    if(!all(group_labels %in% unique(pars_unst$group))){
      if(is.numeric(pars_unst$group)){
        pars_unst$group <- group_labels[pars_unst$group]
      }
    }
    pars_unst$label <- paste0(pars_unst$label, ".", pars_unst$group)
  }
  if("level" %in% names(pars_unst)){
    pars_unst$label <- paste0(pars_unst$label, ".", pars_unst$level)
  }
  # Unst
  pars_unst$confint <- conf_int(x = pars_unst$est, lb = pars_unst$ci.lower, ub = pars_unst$ci.upper)
  pars_unst$est_sig <- est_sig(x = pars_unst$est, sig = pars_unst$pvalue)
  value_columns <- c("est", "se", "pvalue")
  value_columns <- value_columns[which(value_columns %in% names(pars_unst))]
  pars_unst[, value_columns] <- lapply(pars_unst[, value_columns],
                                     formatC, digits = digits, format = "f")
  pars_unst[is.na(pars_unst$z), c("se", "pvalue")] <- ""
  pars_unst[c("z", "ci.lower", "ci.upper")] <- NULL
  # Std
  pars_std <- standardizedsolution(x)
  pars_std$est_sig <- est_sig(x = pars_std$est, sig = pars_std$pvalue)
  pars_std$confint <- conf_int(x = pars_std$est, lb = pars_std$ci.lower, ub = pars_std$ci.upper)
  value_columns <- c("est", "se", "pvalue")
  value_columns <- value_columns[which(value_columns %in% names(pars_std))]
  pars_std[, value_columns] <- lapply(pars_std[, value_columns],
                                       formatC, digits = digits, format = "f")
  pars_std[is.na(pars_std$z), c("se", "pvalue")] <- ""

  pars_std[c("lhs", "op", "rhs", "group", "z", "ci.lower", "ci.upper")] <- NULL

  names(pars_std)[na.omit(match(c("se", "pvalue", "est_sig", "confint"), names(pars_std)))] <- paste0(names(pars_std)[na.omit(match(c("se", "pvalue", "est_sig", "confint"), names(pars_std)))], "_std")
  names(pars_std)[match("est.std", names(pars_std))] <- "est_std"

  results <- cbind(pars_unst, pars_std)

  if(!is.null(columns)){
    #if(standardized){
    #  columns[na.omit(match(c("est", "est_sig", "se", "pval", "confint"), columns))] <- paste0(columns[na.omit(match(c("est", "est_sig", "se", "pval", "confint"), columns))], "_std")
    #}
    results <- results[, na.omit(match(columns, names(results)))]
  } else {
    order_cols <- c("block", "group", "level", "label")
    order_cols <- order_cols[order_cols %in% names(results)]
    remaining_cols <- names(results)[(length(order_cols)+3):(ncol(results))]
    remaining_cols <- remaining_cols[!remaining_cols %in% order_cols]
    order_cols <- c(1:3, match(order_cols, names(results)), match(remaining_cols, names(results)))
    results <- results[, order_cols]
  }
  class(results) <- c("tidy_results", class(results))
  results
}

